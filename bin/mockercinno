#!/usr/bin/env node
const commands = require('commander');
const glob = require('glob');
const chokidar = require('chokidar');
const fs = require('fs');
const path = require('path');

const server = require('../lib/server');
const mockStore = require('../lib/stores').mock;

const preRequiredFiles = [];

const requireAndParse = filePath => {
	try {
		const fileContents = require(path.join(process.cwd(), filePath));
		const parsedContents = typeof fileContents === 'string' ? JSON.parse(fileContents) : fileContents;
		preRequiredFiles.push(filePath);
		return parsedContents;
	} catch (e) {
		console.error(`Failed to parse "${filePath}"`);
	}
};

const requireFilesByGlob = globString => {
	let defaults = [];
	glob.sync(globString, {nodir: true}).map(file => {
		const data = requireAndParse(file);
		defaults = data ? defaults.concat(data) : defaults;
	});

	return defaults;
}

commands
	.option('-f, --file <name>', 'File containing an array of mock schemas.')
	.option('-p, --pattern <glob>', 'File pattern for files containing mock schemas.')
	.option('--port <port>', 'Port for mockercinno to run on.', process.env.MOCK_PORT || 8080)
	.parse(process.argv)


if (commands.file) {
  const data = requireAndParse(commands.file);
	data && mockStore.insert(data);
}

if (commands.pattern) {
		const watcher = chokidar.watch(commands.pattern, {
			ignored: /(^|[\/\\])\../,
			persistent: true
		});

		watcher
	  	.on('add', path => {
				if(!preRequiredFiles.includes(path)) {
					const data = requireAndParse(path);
					data && mockStore.insert(data);
				}
			})
	  	.on('change', filePath => {
				console.log(`${filePath} has changed!`);
				delete require.cache[require.resolve(path.join(process.cwd(), filePath))];
				console.log("Clearing mockStore");
				mockStore.reset();
				console.log("Reloading mockStore");
				mockStore.insert(requireFilesByGlob(commands.pattern));
				console.log('Mocks reloaded!');
			});
}

server.listen(commands.port, () => {
	console.log(`Mock Server started on port ${commands.port}!`);
});
